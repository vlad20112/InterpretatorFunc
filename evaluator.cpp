/*
на вход поступает комбинаторная конструкция,
затем происходит её разбор и вычисление результата.
Требуется использовать доплнительные переменные для хранения промежуточного
результата. Например, может возникнуть ситуация появлнения каррированной функции
(ну там (+2)). Такое следует запоминать для дальнейшего выполнения действий.
Также, в этом модуле должен присутствовать оператор применения(изображается как (@)), 
возможны изменения.
*/
#include <iostream>
#include "combinators.h"
template <class T, class N>
    int applyToCombinator(T a, N b)
    {
        switch (a.getType())
        {
            /*Обработка S - комбинатора*/
        case 0:
        {
            return applyToCombinator((applyToCombinator(a.getFirstArg(), b)),
                                     (applyToCombinator(a.getSecondArg(), b)));
        };
        break;
            /*Обработка К - комбинатора*/
        case 1:
        {
            return a.getFirstArg;
        }
        break;
            /*Обработка I - комбинатора*/
        case 2:
        {
            return b;
        }
        break;
            /*Обработка B - комбинатора*/
        case 3:
        {
        }
        break;
            /*Обработка C - комбинатора*/
        case 4:
        {
        }
        break;
        }
        /*действия оператора применения функции*/
    }